---
layout: post
title: Axon framework reference guide 번역 중.(on going)
date: 2017-12-05 09:36:55
tags: JAVA, Axon, Axon-framework, CQRS
categories: [Java]
---

# Axon framework
## Introduction
Axon은 규모 가변성과 확장성에 대한 문제를 아키텍쳐적으로 직접 해결하여 규모 가변적이고 확장 가능한 애플리케이션을 구축을 도와주는 가벼운 프레임워크입니다. 이 문서는 Axon이 무엇인지와 어떻게 사용하는지 그리고 Axon이 어떻게 개발을 도와 줄 수 있는지를 설명할 것입니다.

Axon과 Axon이 개발되게 된 이야기를 알고 싶으시다면, [Axon Framework Background](Axon Framework Background)를 읽어 보시면 됩니다. 지금 당장 Axon을 사용해서 자신만의 애플리케이션을 만들어 보고 싶으시다면, [시작하기](Getting Started)를 바로 읽어 보시면 됩니다. Axon Framework를 만들어 가는데 도움을 주시고 싶으시다면, [기부하기](Contributing)에서 필요한 정보를 얻으 실 수 있을 겁니다. 마지막으로 이번 장은 몇가지 법적인 문제를 [라이센스](License)부분에서 다루게 됩니다.

## Axon Framework Background, Axon Framework을 개발하게 된 이야기

### A brief history, Axon Framework의 간략한 역사
시간이 흐르면서, 소프트웨어 프로젝트에 대한 요구는 빠르게 증가하였습니다. 회사들은 그들의 사업의 성장과 함께 (웹 기반의)애플리케이션 또한 발전 시키길 원합니다. 이것이 의미하는 바는, 프로젝트와 코드 베이스들만 복잡해지는 것이 아니라 애플리케이션의 기능 또한 끊임 없이 추가되고 수정되며 삭제 됩니다.  겉으로 보기에 구현하기 쉬운 기능을 개발하는데 개발팀이 전체 애플리케이션을 분해해야 한다면 이는 짜증이 나는 상황이 될 수 있습니다. 게다가, 오늘날의 웹 기반의 애플리케이션들은 수백만의 잠재적인 고객들을 대상으로 하기때문에 애플리케이션을 규모 가변적으로 만드는 것은 반드시 필요한 사항입니다.

규모가변적인 이슈들을 해결해 주는 GigaSpaces 그리고 Terra-cotta와 같은 애플리케이션과 프레임워크는 이미 많이 있습니다. 하지만 그들은 한가지 근본적인 결함을 공통적으로 가지고 있습니다. 이들 기술들은 그들이 예전부터 사용해 왔던 계층 구조의 아키텍쳐를 사용한 애플리케이션을 개발자들에게 개발하도록 하여 규모가변성의 문제를 해결하려고 한다는 것입니다. 몇몇 경우에서, 그들은 모든 도메인 로직을 서비스 객체들에게 넣으라고 강요하면서, 실(real) 도메인 모델의 사용을 엄격하게 제한하거나 심지어 막기도 합니다. 비록 그런 방법이 애플리케이션을 만드는 빠른 시작점이더라도, 결국에는 복잡성을 증가 시키고 개발 자체를 느리게 만들어 버립니다.

명령과 조회의 책임 분리(Command Query Responsibility Segregation, 줄여서 CQRS) 패턴은 애플리케이션을 설계하는 방식 자체를 바꾸어 위에서 언급되었던 문제들을 해결합니다. 로직을 분리된 계층으로 분리하는 대신, 로직을 애플리케이션의 상태를 변경하거나 조회를 하는지에 따라서 분리합니다. 다시 말하면, 명령(command)-잠재적으로 애플리케이션의 상태를 변경 시킬 수 있는 행동(action)-들은 애플리케이션의 상태를 조회하는 콤포넌트(component)와는 다른 콤포넌트에서 실행이 됩니다. 이렇게 명령과 조회를 분리하는 가장 큰 이유는 명령과 조회 각각에 대한 기술적 및 비 기술적인 요구사항들이 존재 한다는 것입니다. 명령들이 실행될때, 조회 콤포넌트는 이벤트를 사용하여 (비)동기적으로 갱신이 됩니다. 이렇게 이벤트를 통해 갱신하는 구조는 애플리케이션의 아키텍쳐를 확장성 있고, 규모 가변적이며 궁극적으로 보다 더 유지 보수성을 높여 줍니다.

> **노트**

> CQRS에 대한 상세 설명은 이 문서의 범위에 벗어 납니다. CQRS에 대해 보다 많은 내용을 알고 싶으신 경우, Axon Framework의 웹 싸이트 [www.axonframework.org](www.axonframework.org)를 방문하여 주세요. 해당 웹 싸이트에 CQRS에 대한 정보를 얻을 수 있는 링크들이 있습니다.

CQRS는 오늘날의 소프트웨어 환경을 지배하는 계층화 된 아키텍처와 근본적으로 다릅니다. 개발자들이 자신들의 애플리케이션에 적용할 이 아키텍쳐를 둘러보면서 몇가지 함정에 빠지는 것은 흔한 일입니다.
 이것이 Axon Framework가 생각한 이유입니다. 개발자가 비즈니스 로직에 중점을 두면서 CQRS 응용 프로그램을 구현할 수 있도록 도와줍니다.


## What is Axon?, Axon 이란?
Axon Framework은 CQRS 아키텍쳐 패턴을 개발자가 적용할 수 있도록 지원하여 규모 가변적이고 확장성이 있으며 유지 보수가 가능한 애플리케이션의 구축을 도와 줍니다.

Axon Framework은 aggregate, repository 그리고 이벤트 버스(이벤트를 전파하는 구조)등과 같은 핵심이 되는 빌딩 블럭(building block)들을의 구현체를 제공합니다. 게다가 Axon의 특정 로직에 묶여야 하는 코드 작성 없이 aggregate들과 이벤트 리스너를 개발할 수 있는 애노테이션(annotation)들을 Axon에서 제공합니다. 따라서 개발자는 비지니스 로직에 보다 초점을 맞춰서 개발할 수 있고, 독립된 환경에서 테스트를 쉽게 수행할 수 있습니다.

Axon은 CQRS 아키텍쳐 혹은 관련 콤포넌트들을 숨기려 하거나 하지 않습니다. 따라서 CQRS에 대하 세세히 알고 있는 개발자가 팀안에 한명 혹은 그 이상 있는 것이 좋습니다.

Axon을 사용하여, 올바른 이벤트 리스너에게 이벤트를 전달하고 전달된 이벤트들을 정확한 순서로 동시에 처리하도록 할 수 있습니다. 다중 쓰레드와 관련된 고려 사항들은 일반적으로 다루기 어렵고 버그가 발생해도 추적하기 어려습니다. 심지어 때때로 애플리케이션의 오작동을 일으 킬 수 도 있습니다.  그렇지만 Axon framework 내의 코드들은 다중 쓰레드와 관련된 유형의 버그들이 발생하지 않도록 꼼꼼히 검증이 되어 있습니다.

Axon Framework은 다수의 모듈(jar)로 구성이 되어 있습니다. 각 모듈은 규모 가변적 기반을 구축하기 위한 콤포넌트와 도구들을 제공합니다. Axon Core 모듈은 각기 다른 콤포넌트들을 위한 기본적인 API들과 단일 JVM 애플리케이션에 적합한 솔루션을 제공하는 간단한 구현체들을 제공합니다. 다른 모듈들은 규모 가변성과 고 성능 관련 이슈들을 다루기 위해 특화된 빌딩 블럭들을 제공합니다.


## When to use Axon?, 언제 Axon을 사용해야 할까?
모든 애플리케이션 개발에 Axon이 적합한 것은 아닙니다. 단순히 생성,조회, 수정 및 삭제 기능이 주를 이루며 규모를 가변적으로 늘이고 줄이지 않는 애플리케이션 개발에는 CQRS 혹은 Axon을 사용함으로써 얻는 이득이 없습니다. 그렇지만 다양항 범위의 애플리케이션들의 개발에 Axon을 사용할 수 있습니다.

CQRS와 Axon을 사용하기 좋은 애플리케이션들은 다음의 특징들 중 하나 혹은 그 이상의 특징을 가집니다.

* 오랜 기간동안에 걸쳐 새로운 기능을 추가하여 확장될 가능성이 있는 애플리케이션. 예를 들어, 온라인 스토어는 주문 상태를 추적하는 시스템으로 시작할 수 있습니다. 그런 후에, 제품이 판매될때 마다 제품의 재고량을 갱신하기 위해 재고 정보를 관리하는 시스템을 추가하여 확장할 수 있습니다. 또한 제품 판매에 대한 재무적 통계치를 기록하는 회계 시스템이 필요할 수 있습니다. 소프트웨어 프로젝트가 앞으로 어떻게 발전해 나갈 것인지를 예측하는 것은 힘들지만, 위와 같은 형태로 발전되어 가는 애플리케이션이 분명히 대다수 존재하고 있습니다.

* 쓰기(생성, 수정 그리고 삭제) 대비 조회의 비율이 높은 애플리케이션. 데이터의 쓰기 작업은 많이 이루어 지지 않지만, 그에 비해 조회 작업이 많은 이루어 지는 애플리케이션들이 해당이 됩니다. 조회 대상이 되는 데이터를 포함한 데이터 저장소는 쓰기 명령에 필요한 데이터 저장소와는 다르기 때문이며, 쓰기에 필요한 데이터 저장소에 영향을 주지 않고 조회 데이터 저장소에 조회를 위한 최적화 작업을 수행할 수 있습니다. 이벤트가 발생될때마다 데이터는 갱신되기 때문에, 중복된 데이터는 더이상 문제가 되지 않습니다.

* 데이터를 다양항 형태로 제공하는 애플리케이션. 요즘에 많은 애플리케이션들은 단순히 웹 페이지에 정보를 표시하는데 그치지 않습니다. 예를 들어, 일부 애플리케이션들은 사용자와 관련된 변경 사항들을 사용자에게 알려주기 위해 월별로 사용자에게 이메일을 보냅니다. 검색 엔진이 또 다른 예가 될 수 있습니다. 검색엔진은 동일한 데이터를 사용할 수 있지만, 빠른 검색을 위해 최적화된 방법을 사용합니다. 보고서 도구들은 특정 기간에 걸친 데이터의 변화 추이를 보여주기 위해 정보들을 집계하여 보고서를 생성합니다. 이렇듯 동일한 데이터를 사용하지만 다른 형태로 표시하는 애플리케이션들이 존재하게 됩니다. Axon을 사용하여, 각각의 데이터 저장소들을 실시간 혹은 계획에 맞춰서 독립적으로 갱신할 수 있습니다.

* 다른 목적을 가진 대상별로 분리된 콤포넌트를 가지는 애플리케이션. 온라인 스토어로 예를 들어 보면, 고객들은 제품을 주문하고 주문 상태를 주로 조회하는 반면, 직원들은 제품의 정보와 사용 가능한 제고량을 주로 갱신 할 것입니다. Axon을 사용하면, 직원과 고객의 요구에 맞는 기능을 제공하는 콤포넌트들을 각자의 분리된 서버로 배포할 수 있고 각기 다른 규모 가변 정책(scale policy)을 설정할 수 있습니다. 또한 배포된 서버에 상관없이 각각의 콤포넌트가 원하는 이벤트가 발생하게 되면 Axon은 해당 이벤트를 전달하여 각 콤포넌트들은 최신의 데이터를 유지할 수 있습니다.

* 기존의 애플리케이션과 다른 애플리케이션을 통합하는 것은 까다로운 작업입니다. 이런 경우에도 명령과 이벤트를 사용하여 엄격히 정의된 애플리케이션의 API가 있다면, 다른 외부 애플리케이션과의 통합을 보다 쉽게 할 수 있습니다. 어떤 애플리케이션이라도 명령을 보내고 기존의 애플리케이션에서 생성된 이벤트를 수신할 수 있기 때문입니다.












## Modules
* Core

## When to use
Not a silver bullit
* 쓰기 작업이 적고 읽기 기능이 많은 application.

## Ready to start
### Configure Maven

```

```
## CQRS
CQRS는 **Command Query Responsibility Segregation**의 약자로 조회와 같은 읽기 기능과 저장 및 수정과 같은 쓰기 기능들을 각각의 서비스(application)으로 분리하여 설계하는 기법을 말한다.
CQRS pattern으로 서비스를 구현하기 위해 DDD(Domain Driven Design)을 반드시 알야 하는 것은 아니지만 DDD가 제공하는 *domain*, *bounded context*, *aggregate*와 같은 개념을 먼저 익히는 것이 CQRS로 구현하는 것이 많은 도움이 된다.



And its core blocks are aggregates, repositories and event bus like below.
* Aggregate
* Repository
* Event bug: Dispatching mechanism for events.


## Glossary
### Scalable
"규모 가변성[Scalable]"이라는 용어는 단순 확장성이 있다라는 의미보다는 확장과 축소의 개념을 함께 포함하고 있다. 즉, 사용자의 증감에 따라 애플리케이션의 규모를 동적으로 변경할 수 있다는 의미로 사용할 수 있다.

많은 사용자가 애플리케이션을 사용할때도 scalable한 애플리케이션은 많은 사용자를 감당하고 잘 운영이 되어야 한다. 그리고 사용자의 수가 감소하게 되면 그만큰 애플리케이션을 실행하는 서버의 자원을 아낄 수 있어야 scalable하다고 할 수 있다.

### Extensible
"확장 가능성[extensible]"은 새로운 기능의 추가 및 기존 기능의 확장을 쉽게 할 수 있다라는 의미로 사용된다. 즉, framework을 사용할 경우, framework은 기본 테투리가 되거나 기본적인 기능을 수행하는 객체를 제공해야 하며, framework에서 제공하는 기본 객체의 확장을 쉽게 수행할 수 있어야 한다.


### DDD
DDD는 software application을 개발하기 위한 개발 방법론의 하나이며 다음과 같은 전제를 가지고 있다.
* 핵심 도메인과 도메인의 business logic을 가장 중점적으로 다룬다.
* 기술(개발) 전문가와 도메인(business)전문가의 긴밀한 협업을 통해 특정 도메인의 문제를 해결하기 위한 논리적인(개념적인) 모델을 점진적으로 발전시켜 가는 방법을 지향한다.

DDD model은 domain,
* Domain: 특정 business 영역을 의미한다. 개발하고자 하는 제품의 사업 영역으로 생각할 수 있다.
* Bounded Context: 복잡하고 거대한 시스템을 좀 더 관리 가능한 작은 부분으로 나눠야 하며, 이 과정에서 도출되는 각 부분을 의미한다. 또한 각 부분(bounded context)는 다른 부분과의 의존성을 가지긴 하지만 스스로 해당 영역에서의 기능을 가져야 한다. 다른 부분(bounded context)과의 의존성을 줄이기 위해 보통 이벤트 기반으로 서로 메세지를 주고 받는다.
* Ubiquitous language: Bounded context내의 모델 및 business logic을 설명하기 위한 공통의 언어를 의미한다. 각 Bounded context는 팀을 나누어 개발할 수 있고 팀내의 팀원들은 공통의 언어(기술적 여부를 떠나)로 서로 소통해야 한다.
* Context map: Bounded context내의 model간 혹은 bounded context간의 접점을 분명히 기술해야 한다. 기술적인 관점으로만 기술해야 하는 것이 절대 아닌 팀을 구성하는, 함께 제품을 개발하는 모든 구성원이 이해할 수 있도록 기술 되어야 한다.

### CRUD
CRUD는 특정 데이터에 대한 생성(Create), 조회(Read), 수정(Update) 그리고 삭제(Delete) 작업의 줄임말 입니다.
